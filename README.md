# Что использовал
- БД: PostgreSQL (драйвер pgx)
- Роутер: chi
- Тестирование: testing
- Чтение конфига: cleanenv
- Развертиывание приложения: Docker
- Тестирование API: Postman
# Сборка и запуск проекта  
`docker build -t go-app . && docker compose up --build go-app`
Приложение будет готово к использованию после вывода в консоль строки "Postgres is up - executing command"
# Для запуска тестов  
 `docker-compose run go-app go test ./apitest`
# Какие вопросы были
1. Каким образом реализовать отправку данных с 5-минутной задержкой, если у пользователя нет флага last_revision?
   Сделал локальный кэш, который через горутину обновляется каждые 5 минут из БД (в идеале использовать Redis, но его изучить я не успел)
2. Какой структурой должна обладать БД, чтобы было оптимальнее работать с массивами тегов?
   Я решил создать только одну таблицу в БД, не создавая отдельно таблиц тегов и фич, чтобы было удобнее тестировать. SELECT по фильтру происходит с помощью агрегирующей функции array_agg(), выдавая таким образом сразу весь массив в ответе по указанному тегу или фиче.
3. Как сделать авторизацию через токены?
   Так как сервис не был на это заточен, я решил, что токен будет генириться где-то на стороне, а реализованной сервис будет лишь принимать значение токена.
4. Что можно будет менять в баннере при выполнении patch запроса?
   В описание api было сказано, что запрос меняет лишь содержимое баннера, поэтому это можно сделать с помощью update sql-запроса. Также я решил, что можно будет менять флаг активности баннера через этот запрос. Остальное содержимое баннера не будет меняться. Новые теги для баннеров можно будет добавить через создание баннера с таким же fid и bid.
# ПРИМЕРЫ ЗАПРОСОВ
Запросы в Postman:
1. Post-запрос на добавление баннера 
2. Delete-запрос на удаление баннера
3. Patch-запрос на обновление баннеров
4. Get-запрос для получения баннеров пользователя
5. Get-запрос для получения баннеров админов 

   
   

   

