# Что использовал
- БД: PostgreSQL (драйвер pgx)
- Роутер: chi
- Тестирование: testing, apitest
- Чтение конфига: cleanenv
- Развертиывание приложения: Docker
- Тестирование API: Postman
# Сборка и запуск проекта  
`docker build -t go-app . && docker compose up --build go-app`
Приложение будет готово к использованию после вывода в консоль строки "Postgres is up - executing command"
# Для запуска тестов  
 `docker-compose run go-app go test ./apitest`
# Что было сделано
- При инициализации БД происходит создание одной пустой таблицы(banners)
- 5 методов:
   - POST-запрос для создания нового баннера "/banner"
   - Delete-запрос для удаления баннера "/banner/{id}"
   - Patch-запрос для обновления содержимого сегментов "/banner/{id}"
   - Get-запрос для получения информации о баннерах пользователя "/user_banner" 
   - Get-запрос для получения информации о баннерах по фильтру "/banner"
  -e2e тестирование для сценария получения пользователем своего баннера
# Вопросы по ходу решения задачи
1. Как отдавать информацию пользователям, которые не пользуются флагом last_revision?
   Я решил использовать локальный кэш, который обновляется каждые 5 минут в отдельной горутине. (Конечно для такой задачи лучше подойдет Redis, однако я не изучал его)
2. Как проверять токены авторизации?
   Так как не стояло задачи реализовать сервис авторизации, то я решил, что можно просто проверять Header запроса на наличие определенного значения по ключу "token". То есть я просто проверяю значение токена в заголовке запроса, подразумевая, что токен выдаст пользователю сторонний сервис авторизации.
3. Сколько записей показывать при фильтрации?
   По умолчанию решил назначить значения параметрам limit и offset.
4. Структура БД
   Я решил ограничиться одной таблицей, не создавая отдельных таблиц для хранения тэгов и фич. Сделал я это для того, чтобы было легче тестировать, а также не нужно было создавать отдельные методы для таблицы. Для запроса получения баннеров с фильтрацией я с помощью функции агрегации создаю из отдельных записей "тег-фича-баннер" запись "массив тегов - фича - баннер".
5. Что можно будет изменять при patch-запросе
   Я решил, что нельзя будет менять структуру тэгов и фич во время патч-запроса. Меняться может только содержимое и флаг is_active. Если нужно добавить еще тэгов для баннера, то это можно будет сделать с помощью запроса на создание баннера.
# ПРИМЕРЫ ЗАПРОСОВ
Запросы в Postman:
1. Post-запрос на добавление баннера
 ![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/b004e48f-52ee-4ffa-934c-353474499a76)
при token = admin
![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/95edb055-ac86-4d1a-bb31-982a45494af4)
при token = user
![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/4e58cfc3-3c88-4954-96b1-cdab348f45d1)
при отсутствии токена
2. Delete-запрос на удаление баннера
   ![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/0cdc46a9-c510-45c7-89fa-dc0650b769d1)

3. Patch-запрос на обновление баннера
     ![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/c23bbdb6-3089-4777-8b64-ec3977da6d72)

4. Get-запрос для получения баннера пользователя
   ![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/65dd2de3-29f6-44c3-af63-37c393dd685a)

5. Get-запрос для получения баннеров по фильтру
   ![image](https://github.com/AleksNesterzz/avito_backend_2024/assets/109950730/fae5b8b3-37a9-4c36-aa7f-a123c1049665)
 


   
   

   

